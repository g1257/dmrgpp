ExpressionForAST Documentation
TODO FIXME: Integrate into manual

------------------------------------------------------------------------------------------------------------

Motivation: Functions as input.

The problem that ExpressionForAST solves is that of entering a function in the input file.
There are two ways to do that right now, and it depends what part of the code is involved: some parts
need one kind, some others need another kind. Sorry!

------------------------------------------------------------------------------------------------------------

CanonicalExpression vs. ExpressionForAST

CanonicalExpression is (more or less) the math you write on a piece of paper:
1+2, which would yield 3, whereas ExpressionForAST needs it written in a AST (abstract or acyclical syntax tree) form:
+,1,2 where I used , (comma) as separator.

CanonicalExpression is LESS than the math you write on a piece of paper: It only accepts "canonical" expressions;
see https://code.ornl.gov/gonzalo_3/dmrgpp/-/blob/features/doc/DmrgPlusPlusFp1.tex for the restrictions.

GeneralExpression would be (almost) the math you write in a piece of paper, including any level of nested parenthesis, but this isn't implemented yet.

ExpressionForAST is used in a lot of places in DMRG++, and we'll document those soon, as well as the separators.
Expect another email to the list this or next week.

In the future, you might be able to avoid ASTs and use canonical expressions instead or even general expressions, but for now
I'm afraid that you'll need to understand ExpressionForAST to input functions in DMRG++ and related codes.

------------------------------------------------------------------------------------------------------------

First, I discuss PsimagLite/drivers/calculator.cpp which now uses ExpressionForAST:

cd PsimagLite/drivers
make calculator
./calculator "*:*:+:+:1:3:2:5:2"
yields 35 because it's assumed BREADTH-FIRST as follows:

       *
      /  \
     /    \
    *      +
   / \    / \
  +  1    3  2
/ \
5  2

Note that if we interpret it depth-first we get a different result: 60

              *
             / \
            *   2
           / \
          +  5
         / \
        +   2
       / \
      1   3
and if this is what you wanted it would have to be entered * * 2 + 5 + 2 1 3 instead.

------------------------------------------------------------------------------------------------------------

Second, I copy an old email to this list that (still) works, but the separator might have changed.

Motivation: Read a function from the command line.

Let's say that we want to supply potential V for a Hubbard model, as a function
on the number of sites,

V(i) = -7 if i is even
      =  7 if i is odd

----

AST (Abstract Syntax Tree)

We first need to write this function as an AST:

        ?
      / | \
     /  |  \
    %   7   -7
  / |
i  2


The way we read this is starting from the leaves (terminal nodes).
So i and 2 go to % which means the upward arrow in % is (i % 2)
which is the modulus operation, and thus either 1 if i is odd, or 0 if i is even.
Note how % is a binary operator, that takes 2 arguments and returns a number.

So, the above becomes:

        ?
      / | \
     /  |  \
[0 1]  7   -7
 

Now, we have a ternary operator ?, that takes a number either [0 1] and gives
the second argument (7) if the first number was greater than 0, or the last
argument (-7) if the first number was 0 or smaller.

Thus we get the original V(i) function.

To supply the AST

        ?
      / | \
     /  |  \
    %   7   -7
  / |
i  2

as a string, we give it DEPTH-FIRST, and separated by commas, so we would supply
the function as:
potentialV="?,%,%i,2,7,-7"

Note how we added a % to the i, because we use a % prefix for all variables.

------------------------------------------------------------------------------------------------------------

Third, expressions might appear in predicates, but predicates aren't expressions: predicates
are two expression connected by a comparator.

Here's an old email to the list that still works.

n%%m is a PredicateSimple yielding true
if m divides n, and false otherwise.

We can now use ASTs for PredicateSimple in the form

AST1 op AST2

where op belongs to {"==", "!=", "<=", ">=", ">", "<", "%%"};

and AST is anything that ExpressionCalculator (no longer, now it's ExpressionForAST) can process, and
separated by pipes |

So, n%%m is equivalent (and a shorthand) for

%|n|m==0

---

In other words, %% is an comparator for PredicateSimple,
and % is an operator for ExpressionForAST, but NOT the other way around.

So, now we can combine ExpressionForAST with PredicateAwesome, making it really awesome.

./testPredicate       "%|+|l|1|3==0"      5

is true.

The way this example works is that we look for a Predicate, meaning AST1 comp AST2
The only comparator is == and so AST1 = "%|+|l|1|3" and AST2 = 0
Then AST1 uses | to divide the nodes (because comma was already taken by PredicateAwesome),
and the AST is given depth-first, so we get

     %
    /  \
   +    3
  / \
l  1

which means (l+1)%3 in standard notation, which means take the modulus or remainder of the division of l+1
by 3. With l = 5, AST1 then evaluates to 0, and comparing via == to AST2 = 0 yields true.

------------------------------------------------------------------------------------------------------------
