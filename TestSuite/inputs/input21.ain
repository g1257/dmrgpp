##Ainur 1.0

# This file documents the TimeEvolutionTargeting in DMRG++

# For the theory see our paper
# http://link.aps.org/doi/10.1103/PhysRevE.84.056706
# https://arxiv.org/abs/1103.5391
# G. Alvarez, L. G. G. V. Dias da Silva, E. Ponce, E. Dagotto,
# Time Evolution with the DMRG Algorithm:
# A Generic Implementation for Strongly Correlated Electronic Systems,

# Please see also input20.ain
# which contains the ground state
# run that this run uses
# as starting point
#
# This is a Heisenberg chain of 8 sites
TotalNumberOfSites=8;

# The Heisenberg model has two
# "connections", that is,
# terms going from i to j
# with i not equal j
NumberOfTerms=2;

# The first term is the S^+_i S^_j connection
gt0:GeometryKind="chain";
gt0:GeometryOptions="ConstantValues";
# This is the value of J_pm for all N-1 chain connections
# Here N = 8 so there are 7 connections
# An automatic 0.5 is multiplied by DMRG++ so you don't have to include it.
# so you get 0.5*J_pm * (S+i S-j + S-i S+j)
gt0:dir0:Connectors=[1.0];

# The second term is the S^z_i S^z_j connection
gt1:GeometryKind="chain";
gt1:GeometryOptions="ConstantValues";
# Again Jz = 1 for all N - 1 chain connections of the open chain
# Here N = 8 so there are 7 connections
gt1:dir0:Connectors=[1.0];

# The Heisenberg model
Model="Heisenberg";
# With s = 1/2 or 2s = 1
HeisenbergTwiceS=1;

# The SolverOptions are
# twositedmrg : recommended
# TimeStepTargeting: this tells DMRG++ to do time evolution instead of g.s. calculation
# restart : we restart from a g.s. run done in input20.ain
SolverOptions="twositedmrg,TimeStepTargeting,restart";

# Ignored but mandatory string
Version="247b335fe1542909b90be8647456bfd8fd56191c";

# The file data20.hd5 must be present; the extension hd5 can be left out, as we do here
RestartFilename="data20";

# This run will create data21.hd5
OutputFile="data21";

# The value of kept states m for the infinite loop is ignored because we
# are restarting. But this value is mandatory and may be used as minimum m value
# if tolerance is enabled, as it is by default.
InfiniteLoopKeptStates=60;

# The finite loops
# There are two finite loops mentioned explicitly.
# The first starts from where input20 left off and goes all the way to the left,
# and the second loop all the way to the right.
#
# The value 150 refers to the kept states that will be used, and
# sets the maximum number of kept states. The solver will use fewer states if the
# target tolerance is met earlier, but it will cap at this value regardless of
# whether the tolerance is satisfied. The .cout file will log details.
#
# (Tolerance can be specified explicityly with
# Tolerance=1e-10;
# for example, and don't forget the semicolon at the end.
# Moreover, you can set the minimum "m" value after it, like so:
# Tolerance=1e-10,100;
#)
#
# The number 2 tells DMRG++ to not recompute the g.s., only to wave-function-transform (WFT)
# it. In the future we'll use labels like @wft instead of 2 for this, but for now
# you have to enter the number 2 there.
FiniteLoops=[[@auto, 150, 2],[@auto, 150, 2]];

# We repeat the above FiniteLoops line 2 times. So it's as if you had
# written 6 finite loops: the explicitly written 2, plus the 2 repetitions each containing two in turn.
# This saves typing.
RepeatFiniteLoopsTimes=2;

# This is the number of "spins up" for Heisenberg spin=1/2, so we get Sz = 0 as a local symmetry.
# For spin > 1/2, this is \sum_i (spin + m_i) = const., where the sum over i runs over all sites.
# Note that in all cases this is a non-negative integer.
# In other words, DMRG++ uses m + j instead of just m for the symmetry, so that the resulting number
# is both an integer and non-negative.
TargetSzPlusConst=4;

# Many vectors will be included in the density matrix or actually the SVD decomposition (see paper mentioned above)
# Each vector will have a weight, so that all weights add up to 1.
# This is the weight of the g.s. vector. All other weights are computed automatically by DMRG++ to complete the sum.
GsWeight=0.1;

# exp(-H *TSPTau/Nsteps) will be applied.
# Usually, tau is 0.1 or 0.2 but not more.
TSPTau=0.1;

# The number of Nsteps in the formula above.
# Each of the 5 time vectors will be accessible with P0, P1, etc.
TSPTimeSteps=5;

# The time advancement happens after this many movements, in units of sites.
# Keep this number a multiple of (N-2), which in this case is 6.
TSPAdvanceEach=6;

# The algorithm to be used for the time evolution; see reference above.
TSPAlgorithm="Krylov";

# The site(s) where the operators below in this input will be applied to the g.s.
# Here we use the (one of the) center site.
# Note that time evolution targeting goes through stages, and the next stage doesn't start
# until the previous stage has finished.
#
# stage 1 : disabled: until the delay counter if any has been reached; see TSPDelay below.
#
# stage 2 : operators: apply to the g.s. all operators listed in this input
#           Remember that this can only be done as sites come into view in the DMRG sweeping.
#           Operators are applied in the order listed, so sites here is ordered
#           by operators listed below.
#
# stage 3: time evolution: Do the time evolution proper;
#          This stage has a counter for time advancement. When time advancement happens,
#          the last time vector (P4) is moved to become the first (P0), all the
#          other time vectors are recomputed from the new first time vector,
#          and the advancement counter is reset to zero.
TSPSites=[4];

# The delay before stage 2 (operator application), in finite loop units.
# If g.s. was done in a previous run, the recommended value here is 0 = no delay.
TSPLoops=[0];

# If more than one operator is mentioned below, this indicates whether they are summed
# or multiplied. If only one operator is present, then this has no effect.
#
# (This method of doing things can only do sums or products, but not
# sums of products or more complicated things. If those are needed, they should be done
# with TargetingExpression instead, and before this run, and then here only the identity should be applied.
# TargetingExpression isn't documented here.)
TSPProductOrSum="product";

# We apply only one operator, TSPOp0.
# We provide it by expression (recommended). It could also be given as a raw matrix or in a file.
string TSPOp0:TSPOperator=expression;
# The name of the operator
string TSPOp0:OperatorExpression="sz";
# Use prelabels TSPOp1, etc, if other operators are needed. Remember that the sites
# will be listed in TSPSites above in this order.
#
# How to run.
# Make sure you produce the g.s. first with
# ./dmrg -f input20.ain
#
# In situ time measurements can be done only for one-points, as follows:
#
# ./dmrg -f input21.ain "<gs|sz|P0>"
#
# which would measure the time-dependent correlation
#
# <gs|sz_i exp(-iHt) sz_4 |gs> (*)
#
# where 4 is the center site as selected in TSPSites, sz selected in TSPOp0,
# and because |P0> = exp(-iHt) sz_4 |gs>
#
# The output would appear in the .cout file and one can do
#
# grep sz runForinput21.cout
#
# which would display things like
#
# 5 (-0.183963,0.056750) 0.300000 <gs|sz|P0> (-0.000000,0.000000)
#
# The first number is the site i in formula (*) above, so this line
# shows results for i = 5.
#
# The second number is the value of <gs|sz_i exp(-iHt) sz_4 |gs>
# which is complex as expected.
#
# The third number (0.3) indicates the time t in the formula (*).
#
# The fourth is the string being computed; make sure you understand
# the meaning of P0 as indicated above.
#
# (In general |P0> = exp(-iHt) O_{X-1} op ... op O_1 op O_0 |gs>
# where the O_x are the operators you included in the input file
# with TSPOp0, TSPOp1, etc. and are applied as shown, with O_0 applied
# first to the |gs>. Note that the sites assigned to these operators
# are to be given in TSPSites.
# The op is either + or * among operators on different sites,
# depending on the value of TSPProductOrSum.
# More complicated expressions aren't possible with this setup, but see
# my comment above about TargetingExpression.)
#
# The last number, that I call "superdensity", indicates whatever label
# you wanted to calculate, but with the things between the pipes | | deleted.
# In this case the label is <gs|sz|P0>, so the thing between the pipes is sz,
# and without it we get <gs|P0>, which turns out to be zero, as it should.
#
# To compute the Fourier transform in both space and time, the following can be done
#
#  ../scripts/fourierTimeSpace.pl runForinput21.cout "<gs|sz|P0>" 0 4 0.1
#
# where the output has the following columns
# # momentum omega real_value imag_value
# and a break is printed when omega changes.
#
# For many-point time measurements, observe and saving must be used; this is out-of-scope here.
#
# For Hamiltonians that explicitly depend on time, I'll comment another input shortly. The
# procedure will be very similar to the one here.
